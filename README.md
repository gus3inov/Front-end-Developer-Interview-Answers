# Ответы на вопросы кандидату на должность front-end разработчика

**Замечание:** Данный репозиторий содержит ответы на подборку вопросов которые собраны в [Front-end-Developer-Interview-Questions](https://github.com/h5bp/Front-end-Developer-Interview-Questions)
Ответы на данные вопросы собраны с различных книг, статей и технических ресурсов. Ссылки на ресурсы будут в приложении данного README.
Собранные ответы могут быть несколько длинные и многословные, читателю следует выделить ключевые моменты.

## <a name='toc'>Содержание</a>

  1. [Общие вопросы](#general)
  1. [Вопросы по HTML](#html)
  1. [Вопросы по CSS](#css)
  1. [Вопросы по JavaScript](#js)
  1. [Вопросы по тестированию](#testing)
  1. [Вопросы по производительности](#performance)
  1. [Вопросы по сетям](#network)
  1. [Примеры кода на JavaScript](#jscode)
  1. ["Светская беседа"](#fun)

#### [[⬆]](#toc) <a name='js'>Ответы на вопросы по JavaScript:</a>

##### :question: Q - Объясните делегирование событий.
###### :heavy_check_mark: A:
 Он заключается в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому – мы ставим один обработчик на их общего предка. Из него можно получить целевой элемент event.target, понять на каком именно потомке произошло событие и обработать его. 

[Ссылка на ресурс](https://learn.javascript.ru/event-delegation)
___

##### :question: Q - Что такое область видимости ?
###### :heavy_check_mark: A: 
Область видимости — это набор правил, которые определяют где и как переменная (идентификатор) могут быть найдены. Этот поиск может осуществляться для целей присваивания значения переменной, которая является LHS (left-hand-side) ссылкой, или может осуществляться для целей извлечения ее значения, которое является RHS (right-hand-side) ссылкой. Область видимости — это набор правил поиска переменных по их идентификатору. Однако, обычно бывает более одной Области видимости.
Также как блок или функция вкладывается внутрь другого блока или функции, области видимости вкладываются внутрь других областей. Поэтому, если переменную не найти в ближайшей области видимости, Движок заглядывает в следующую внешнюю по отношению к этой область видимости, продолжая так до тех пор, пока не найдет или пока не достигнет самой внешней (т.е. глобальной) области.

[Ссылка на ресурс](https://github.com/azat-io/you-dont-know-js-ru/blob/master/scope%20%26%20closures/ch1.md)
___

##### :question: Q - Объясните, как this работает в JavaScript.
###### :heavy_check_mark: A: 
На самом деле `this` - это привязка контекста к функции, которая создается во время вызоыва функции, и на что она ссылается определяется тем, где и при каких условиях функция была вызвана. При каждом вызове функции создается новый `this`
Привязка бывает разных видов:
 - Привязка по умолчанию: происходит при прямом вызове функции, которая необернута ссылкой на функцию.`undefined` в режиме `strict mode`, в противном случае объект `global`.
 - Неявная привязка: точка вызова использует контекст объекта, чтобы ссылаться на функцию, поэтому можно сказать, что объект объекта "владеет" или "содержит" ссылку на функцию в момент вызова функции.
 - Явная привязка: у всех функций в js есть несколько методов, доступных через их прототип. Среди этих методов присутствуют `call` и `apply`. ? Они оба принимают в качестве первого параметра объект, который будет использоваться в качестве `this`, а затем вызывают функцию с указанным `this`. Отличие между этими двумя методами лишь в остальных параметрах. В `call` после первого параметра мы передаем список параметров которые будут прокинуты в функции, а `apply` вторым параметром мы передаем массив, который будет развернут в функции в качестве списка параметров.
 - Привязка new: При вызове функции с помощью ключевого слова `new`, вызывается так называемый метод конструктор, который создает новый-сконструированный объект, и данный объект устанавливается как привязка `this` для этого вызова функции.

[Ссылка на ресурс](https://github.com/azat-io/you-dont-know-js-ru/blob/master/this%20%26%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes)
___

##### :question: Q - Что вы думаете о AMD против CommonJS?
###### :heavy_check_mark: A: 
CommonJS и AMD являются спецификациями (или форматами) о том, как модули и их зависимости должны быть объявлены в приложениях javascript. AMD начинала разработку как подпроект спецификации формата в списке CommonJs, так как эти две группы в итоге имели разные планы, дальнейшая разработка формата AMD была перенесена в amdjs group.
CommonJS охватывает более широкий круг проблем и он лучше подходит для развития на стороне сервера с учетом его синхронного характера, а AMD лучше подходит для развития клиентской стороны (браузера) учитывая его асинхронный характер.
___
##### :question: Q - Объясните, почему это не является IIFE: `function foo(){ }();`
- Что необходимо изменить, чтобы это стало IIFE?
###### :heavy_check_mark: A: 
В этом примере будет выброшено исключение `SyntaxError`, в данном случае это объявление функции и скобки в конце не будут отнесены к функции, так как они играют роль опператора группировки. Такие скобки не могут быть пустыми, поэтому будет выбрашено исключение.
Для того что бы переделать этот пример под немедленно вызываемую функцию - нужно обернуть функциональное выражение в скобки и удалить именование функции
___
##### :question: Q - Что такое замыкание и как/для чего его используют?
###### :heavy_check_mark: A
Замыкание — это когда функция может запомнить и иметь доступ к своей лексической области видимости даже тогда, когда она вызывается вне своей лексической области видимости.

[Ссылка на ресурс](https://github.com/azat-io/you-dont-know-js-ru/blob/master/scope%20%26%20closures/ch5.md)
___
##### :question: Q - Расскажите, что такое "hoisting".
###### :heavy_check_mark: A: 
Прежде чем движок JavaScript начнет интепретировать код, он его скомпилирует. Один из процессов компиляции является нахождение и ассоциация всех объявлений с их соответствующими областями видимости. 
Hoisting это процесс поднятие декларации переменной в начало области видимости. Каждое поднятие соотносится с областью видимости. Так же важно отметить что  объявления поднимаются, а присваивания, даже присваивания функциональных выражений, не поднимаются.

[Ссылка на ресурс](https://github.com/azat-io/you-dont-know-js-ru/blob/master/scope%20%26%20closures/ch4.md)
___

##### :question: Q - В каких случаях обычно используются анонимные функции?
###### :heavy_check_mark: A: 
Анонимные функции очень часто используются для выполнения какого-то кода в коллбэках, где в целом не нужно создавать отдельную именную функцию под это действие. Так можно присвоить переменной.
___

##### :question: Q - В чём различие между переменными, созданными при помощи let, var и const?
###### :heavy_check_mark: A: 
Отличие `let` и `const` от `var` в том, что они декларируются в своей области видимости (в блоке `{...}`). Другими словами, они не всплывают.
Отличие `const` от `let` в том, что они обязательно должны быть определены со значением и не могут изменяться впоследствии. 
___

##### :question: Q - Можете ли вы привести пример использования стрелочных функции =>? Чем они отличаются от других функций?
###### :heavy_check_mark: A: 
Главное отличие стрелочных функций в том, что они не имеют своего `this`. Это несет за собой естественное ограничение, такии функции нельзя использовать в качестве конструктора. 

Есть тонкое различие между функцией стрелкой `=>` и обычной функцией, у которой вызван .bind(this):

 - Вызовом `.bind(this)` мы передаём текущий `this`, привязывая его к функции.
 - При `=>` привязки не происходит, так как функция стрелка вообще не имеет контекста this. Поиск this в ней осуществляется так же, как и поиск обычной переменной, то есть, выше в замыкании. До появления стандарта ES-2015 такое было невозможно.
___

##### :question: Q - В чем разница между host-объектами и нативными объектами
###### :heavy_check_mark: A:
 - Собственные объекты: `Object` (конструктор), `Date`, `Math`, `parseInt`, `eval`, строковые методы, такие как `indexOf` и `replace`, методы массивов и т.д - основные предопределенные объекты, всегда доступные в JavaScript
 - Объекты хоста (при условии среды браузера): `window`, `document`, `location`, `history`, `XMLHttpRequest`, `setTimeout`, `getElementsByTagName`, `querySelectorAll` и т.д - Они отличаются от встроенных объектов, потому что не все окружения будут иметь одни и те же объекты хоста. Если JavaScript работает за пределами браузера, например, на языке сценариев на стороне сервера, например, в Node.js, будут доступны разные объекты хоста.
 ___
 
##### :question: Q - В чём различие между переменными, значение которых: null, undefined ?
Как бы вы проверили их на каждое из этих значений?
###### :heavy_check_mark: A:
 - Оба значения обычно используются, чтобы указать на отсутствие чего-то. `undefined` более общий, используемый в качестве значения по умолчанию для переменных до тех пор, пока им не присвоено какое-либо другое значение, как значение аргументов функции, которые не были указаны при вызове функции, и как значение, которое вы получаете при запросе объекта для имущества, которого у него нет. Но он также может быть явно использован во всех этих ситуациях. (Существует разница между объектом, не имеющим свойства, и имеющим свойство со значением undefined; существует разница между вызовом функции со значением undefined для аргумента, и полностью оставить этот аргумент.)
 - `null` является несколько более конкретным, чем undefined: Это пустая ссылка на объект. Разумеется, JavaScript явно напечатан, но не все вещи, с которыми взаимодействует JavaScript, свободно набираются. Если API, подобный DOM в браузерах, нуждается в ссылке на объект, которая пуста, мы используем null, а не undefined, Аналогичным образом, DOM getElementById операция возвращает ссылку на объект - либо действительную (если она найдена элементом DOM), либо null (если это не так).
 ___

##### :question: Q - В чем разница между == и === ?
###### :heavy_check_mark: A:
Единственное различие между ними состоит в том, что `==` будет делать принуждение типа, чтобы попытаться совместить значения, и `===` не будет. 
 ___
##### :question: Q - В чем разница между feature detection (определение возможностей браузера), feature inference (предположение возможностей) и анализом строки user-agent?
###### :heavy_check_mark: A: 
 - В feature detection мы определяем наличие браузера на какую либо функциональность, и уже в зависимости от результата проверки работаем с данной функциональностью.
 - В случае feature inference мы так же определяем наличие функции у бразуера, но в зависимости от проверки используем другую функциональность, как бы предполгая что она так же будет существовать
 - Проверка строки user agent являяется старой практикой. user agent браузера содержит название и версию приложения, а также данные об операционной системе компьютера: версия, разрядность, язык по умолчанию и другие параметры.
 ___
##### :question: Q - Расскажите об Ajax как можно более подробно.
###### :heavy_check_mark: A:
Ajax - это подход, с помощью которого можно фоново обмениваться информацией браузеру с сервером. Использование AJAX для раскрутки сайта позволяет улучшить его юзабилити (приложения становятся более удобными и быстрыми для посетителей), функциональность и внешний вид страниц.
Ajax позволяет обращаться к серверу, без перезагрузки страницы, с помощью технологии XMLHttpRequest.
Объект XMLHttpRequest (или подобные механизмы) используется для асинхронного взаимодействия с сервером, обработки запросов пользователя и загрузки в процессе работы необходимых данных.
 ___
 
##### :question: Q - Какие преимущества и недостатки в использовании Ajax?
###### :heavy_check_mark: A:
Преимущества:
 - мы можем экономить трафик, загружая только часть страницы которая изменилась.
 - снижение нагрузки на сервер, так как серверу нет необходимости снова генерировать страницу и ее передавать клиенту
 - интерактивность интерфейса, загрузка изменившейся части происходит быстрее, чем полная генерация страницы, соответственно пользователь видит результат своих действий быстрее
 Недостатки:
 - поисковые машины не могут выполнять js, поэтому приходится реализовывать серверный рендеринг приложения
 - усложенение проекта путем переноса логики по форматированию данных на клиент
 - без включенного javascript мы не сможем построить приложение на ajax
 - риск нагрузить клиент ajax запросами
 ___

##### :question: Q - Объясните, как работает JSONP (и почему это не совсем AJAX).
###### :heavy_check_mark: A:
JSONP позволяет выполнять запросы к другому домену, а XHR не позволяет это делать.
Выполнить кросс доменный запрос мы можем добавить `head` страницы новый тег, `script` и в `src` установить адрес запроса и параметры.
 ___
 
##### :question: Q - Объясните event bubbling
###### :heavy_check_mark: A:
 При наступлении события обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе, затем выше и так далее, вверх по цепочке вложенности.
 Всплытие идёт прямо наверх. Обычно событие будет всплывать наверх и наверх, до элемента `<html>`, а затем до `document`, а иногда даже до `window`, вызывая все обработчики на своем пути.
 Всплытие можно остановить с помощью вызова метода `event.stopPropagation`
 - Для того, чтобы полностью остановить обработку, современные браузеры поддерживают метод event.stopImmediatePropagation(). Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.
 
 [Ссылка на ресурс](https://learn.javascript.ru/event-bubbling)
 ___
  
##### :question: Q - В чём разница между "атрибутом" (attribute) и "свойством" (property)?
###### :heavy_check_mark: A:
Атрибуты – это то, что написано в HTML. В отличие от свойств, атрибуты:
 - Всегда являются строками.
 - Их имя нечувствительно к регистру
 - Видны в `innerHTML`

Свойство – это то, что находится внутри DOM-объекта. Пользовательские DOM-свойства:
 - Могут иметь любое значение.
 - Названия свойств чувствительны к регистру.
 - Работают за счет того, что DOM-узлы являются объектами JavaScript.
 
[Ссылка на ресурс](https://learn.javascript.ru/attributes-and-custom-properties)
 ___
 
##### :question: Q - Почему не следует расширять нативные JavaScript объекты?
###### :heavy_check_mark: A:
На этот счет бытуют разные мнения. Многие предпологают что расширение стандартных объектов вполне допустимо, но перед тем как создать метод, нужно проверить его на сущестование, что бы случайно не затереть уже имеющийся метод.
 ___
 
##### :question: Q - В чём разница между событием document load и событием document DOMContentLoaded?
###### :heavy_check_mark: A:
Эти стадии играют важную роль. 
 - С помощью `document load`, мы можем проверить загрузил ли браузер ресурсы
 - `DOMContentLoaded` означает, что браузер полностью загрузил  HTML и построил DOM-дерево, но при этом, возможно, ещё не догрузились какие-то картинки или стили.

[Ссылка на ресурс](https://learn.javascript.ru/onload-ondomcontentloaded)
___
 
##### :question: Q - Почему тернарный оператор так называется?
###### :heavy_check_mark: A:
Оператор называется таким образом, потому что ему требуется три операнда для выполнения выражения.
___

