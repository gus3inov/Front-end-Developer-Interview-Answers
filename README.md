# Ответы на вопросы кандидату на должность front-end разработчика

**Замечание:** Данный репозиторий содержит ответы на подборку вопросов которые собраны в [Front-end-Developer-Interview-Questions](https://github.com/h5bp/Front-end-Developer-Interview-Questions)
Ответы на данные вопросы собраны с различных книг, статей и технических ресурсов. Ссылки на ресурсы будут в приложении данного README.
Собранные ответы могут быть несколько длинные и многословные, читателю следует выделить ключевые моменты.

## <a name='toc'>Содержание</a>

  1. [Общие вопросы](#general)
  1. [Вопросы по HTML](#html)
  1. [Вопросы по CSS](#css)
  1. [Вопросы по JavaScript](#js)
  1. [Вопросы по тестированию](#testing)
  1. [Вопросы по производительности](#performance)
  1. [Вопросы по сетям](#network)
  1. [Примеры кода на JavaScript](#jscode)
  1. ["Светская беседа"](#fun)

#### [[⬆]](#toc) <a name='js'>Ответы на вопросы по JavaScript:</a>

##### :question: Q - Объясните делегирование событий.
###### :heavy_check_mark: A:
 Он заключается в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому – мы ставим один обработчик на их общего предка. Из него можно получить целевой элемент event.target, понять на каком именно потомке произошло событие и обработать его. 
[Ссылка на ресурс](https://learn.javascript.ru/event-delegation)
___

##### :question: Q - Что такое область видимости ?
###### :heavy_check_mark: A: 
Область видимости — это набор правил, которые определяют где и как переменная (идентификатор) могут быть найдены. Этот поиск может осуществляться для целей присваивания значения переменной, которая является LHS (left-hand-side) ссылкой, или может осуществляться для целей извлечения ее значения, которое является RHS (right-hand-side) ссылкой.Мы говорили, что Область видимости — это набор правил поиска переменных по их идентификатору. Однако, обычно бывает более одной Области видимости.
Также как блок или функция вкладывается внутрь другого блока или функции, области видимости вкладываются внутрь других областей. Поэтому, если переменную не найти в ближайшей области видимости, Движок заглядывает в следующую внешнюю по отношению к этой область видимости, продолжая так до тех пор, пока не найдет или пока не достигнет самой внешней (т.е. глобальной) области.

[Ссылка на ресурс](https://github.com/azat-io/you-dont-know-js-ru/blob/master/scope%20%26%20closures/ch1.md)
___

##### :question: Q - Объясните, как this работает в JavaScript.
###### :heavy_check_mark: A: 
На самом деле `this` - это привязка контекста к функции, которая создается во время вызоыва функции, и на что она ссылается определяется тем, где и при каких условиях функция была вызвана. При каждом вызове функции создается новый `this`
Привязка бывает разных видов:
 - Привязка по умолчанию: происходит при прямом вызове функции, которая необернута ссылкой на функцию.`undefined` в режиме `strict mode`, в противном случае объект `global`.
 - Неявная привязка: точка вызова использует контекст объекта, чтобы ссылаться на функцию, поэтому можно сказать, что объект объекта "владеет" или "содержит" ссылку на функцию в момент вызова функции.
 - Явная привязка: у всех функций в js есть несколько методов, доступных через их прототип. Среди этих методов присутствуют `call` и `apply`. ? Они оба принимают в качестве первого параметра объект, который будет использоваться в качестве `this`, а затем вызывают функцию с указанным `this`. Отличие между этими двумя методами лишь в остальных параметрах. В `call` после первого параметра мы передаем список параметров которые будут прокинуты в функции, а `apply` вторым параметром мы передаем массив, который будет развернут в функции в качестве списка параметров.
 - Привязка new: При вызове функции с помощью ключевого слова `new`, вызывается так называемый метод конструктор, который создает новый-сконструированный объект, и данный объект устанавливается как привязка `this` для этого вызова функции.

[Ссылка на ресурс](https://github.com/azat-io/you-dont-know-js-ru/blob/master/this%20%26%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes)
___

##### :question: Q - Что вы думаете о AMD против CommonJS?
###### :heavy_check_mark: A: 
CommonJS и AMD являются спецификациями (или форматами) о том, как модули и их зависимости должны быть объявлены в приложениях javascript. AMD начинала разработку как подпроект спецификации формата в списке CommonJs, так как эти две группы в итоге имели разные планы, дальнейшая разработка формата AMD была перенесена в amdjs group.
CommonJS охватывает более широкий круг проблем и он лучше подходит для развития на стороне сервера с учетом его синхронного характера, а AMD лучше подходит для развития клиентской стороны (браузера) учитывая его асинхронный характер.
___
##### :question: Q - Объясните, почему это не является IIFE: `function foo(){ }();`
- Что необходимо изменить, чтобы это стало IIFE?
###### :heavy_check_mark: A: 
В этом примере будет выброшено исключение `SyntaxError`, в данном случае это объявление функции и скобки в конце не будут отнесены к функции, так как они играют роль опператора группировки. Такие скобки не могут быть пустыми, поэтому будет выбрашено исключение.
Для того что бы переделать этот пример под немедленно вызываемую функцию - нужно обернуть функциональное выражение в скобки и удалить именование функции
___
##### :question: Q - Что такое замыкание и как/для чего его используют?
###### :heavy_check_mark: A
Замыкание — это когда функция может запомнить и иметь доступ к своей лексической области видимости даже тогда, когда она вызывается вне своей лексической области видимости.

[Ссылка на ресурс](https://github.com/azat-io/you-dont-know-js-ru/blob/master/scope%20%26%20closures/ch5.md)
___
##### :question: Q - Расскажите, что такое "hoisting".
###### :heavy_check_mark: A: 
Прежде чем движок JavaScript начнет интепретировать код, он его скомпилирует. Один из процессов компиляции является нахождение и ассоциация всех объявлений с их соответствующими областями видимости. 
Hoisting это процесс поднятие декларации переменной в начало области видимости. Каждое поднятие соотносится с областью видимости. Так же важно отметить что  объявления поднимаются, а присваивания, даже присваивания функциональных выражений, не поднимаются.

[Ссылка на ресурс](https://github.com/azat-io/you-dont-know-js-ru/blob/master/scope%20%26%20closures/ch4.md)
___

##### :question: Q - В каких случаях обычно используются анонимные функции?
###### :heavy_check_mark: A: 
Анонимные функции очень часто используются для выполнения какого-то кода в коллбэках, где в целом не нужно создавать отдельную именную функцию под это действие. Так можно присвоить переменной.
___

##### :question: Q - В чём различие между переменными, созданными при помощи let, var и const?
###### :heavy_check_mark: A: 
Отличие let и const от var в том, что они декларируются в своей области видимости (в блоке {...}). Другими словами, они не всплывают.
Отличие const от let в том, что они обязательно должны быть определены со значением и не могут изменяться впоследствии. 
___

##### :question: Q - Можете ли вы привести пример использования стрелочных функции =>? Чем они отличаются от других функций?
###### :heavy_check_mark: A: 
Главное отличие стрелочных функций в том, что они не имеют своего `this`. Это несет за собой естественное ограничение, такии функции нельзя использовать в качестве конструктора. 

Есть тонкое различие между функцией стрелкой => и обычной функцией, у которой вызван .bind(this):

 - Вызовом .bind(this) мы передаём текущий this, привязывая его к функции.
 - При => привязки не происходит, так как функция стрелка вообще не имеет контекста this. Поиск this в ней осуществляется так же, как и поиск обычной переменной, то есть, выше в замыкании. До появления стандарта ES-2015 такое было невозможно.
___

##### :question: Q - В чем разница между host-объектами и нативными объектами
###### :heavy_check_mark: A:
 - Собственные объекты: Object (конструктор), Date, Math, parseInt, eval, строковые методы, такие как indexOf и replace, методы массивов и т.д - основные предопределенные объекты, всегда доступные в JavaScript
 - Объекты хоста (при условии среды браузера): window, document, location, history, XMLHttpRequest, setTimeout, getElementsByTagName, querySelectorAll и т.д - Они отличаются от встроенных объектов, потому что не все окружения будут иметь одни и те же объекты хоста. Если JavaScript работает за пределами браузера, например, на языке сценариев на стороне сервера, например, в Node.js, будут доступны разные объекты хоста.
 
 ___
